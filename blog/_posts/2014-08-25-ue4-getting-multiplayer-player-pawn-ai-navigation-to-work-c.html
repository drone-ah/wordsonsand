---
layout: post
title: "[UE4] Getting Multiplayer Player Pawn AI Navigation to work (C++)"
date: 2014-08-25 15:52:34.000000000 +01:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Game Development
tags:
- UE4
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '5186049052'
  _elasticsearch_data_sharing_indexed_on: '2024-11-18 14:55:00'
permalink: "/2014/08/25/ue4-getting-multiplayer-player-pawn-ai-navigation-to-work-c/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body></p>
<p>Unreal Engine is an awesome piece of technology making it easy to do almost anything you might want.</p>
<p>When using the Top Down view however, there is a hurdle to get over when trying to get multiplayer to work. This is a C++ project solution to this problem based on a <a href="https://answers.unrealengine.com/questions/34074/does-ue4-have-client-side-prediction-built-in.html">BluePrints solution</a>.</p>
<p>The basic problem stems from the fact that</p>
<blockquote>
<p>"<em>SimpleMoveToLocation</em> was never intended to be used in a network environment. It's simple after all ;) Currently there's no dedicated engine way of making player pawn follow a path. " (from the same page)</p>
</blockquote>
<p>To be able to get a working version of <em>SimpleMoveToLocation</em>, we need to do the following:</p>
<ul>
<li>Create a proxy player class (BP_WarriorProxy is BP solution)</li>
<li>Set the proxy class as the default player controller class</li>
<li>Move the camera to the proxy (Since the actual player class is on the server, we can't put a camera on it to display on the client)</li>
</ul>
<p>The BP solution talks about four classes - our counterparts are as follows:</p>
<ul>
<li>BP_WarriorProxy: ADemoPlayerProxy</li>
<li>BP_WarriorController: ADemoPlayerController (Auto-created when creating a c++ top down project)</li>
<li>BP_Warrior: ADemoCharacter (Auto-created when creating a C++ top down project)</li>
<li>BP_WarriorAI: AAIController - we have no reason to subclass it.</li>
</ul>
<p>So, from a standard c++ top down project, the only class we need to add is the ADemoPlayerProxy - so go ahead and do that first.</p>
<p>The first thing we'll do is rewire the ADemoGameMode class to initialise the proxy class instead of the default MyCharacter Blueprint.</p>
<p> </p>
<p>[code language="cpp"]<br />
ADemoGameMode::ADemoGameMode(const class FPostConstructInitializeProperties&amp;amp; PCIP) : Super(PCIP)<br />
{<br />
    // use our custom PlayerController class<br />
    PlayerControllerClass = ADemoPlayerController::StaticClass(); </p>
<p>    // set default pawn class to our Blueprinted character<br />
    /* static ConstructorHelpers::FClassFinder&lt;apawn&gt; PlayerPawnBPClass(TEXT("/Game/Blueprints/MyCharacter"));<br />
    if (PlayerPawnBPClass.Class != NULL)<br />
    {<br />
        DefaultPawnClass = PlayerPawnBPClass.Class;<br />
    }*/ </p>
<p>    DefaultPawnClass = ADemoPlayerProxy::StaticClass(); } </p>
<p>[/code]</p>
<p> </p>
<p>Our Player Proxy class declaration</p>
<p>[code language="cpp"]<br />
/* This class will work as a proxy on the client - tracking the movements of the<br />
 * real Character on the server side and sending back controls. */<br />
UCLASS() class Demo_API ADemoPlayerProxy : public APawn<br />
{<br />
    GENERATED_UCLASS_BODY()<br />
    /** Top down camera */<br />
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera) TSubobjectPtr&lt;class ucameracomponent=""&gt; TopDownCameraComponent; </p>
<p>    /** Camera boom positioning the camera above the character */<br />
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera) TSubobjectPtr&lt;class uspringarmcomponent=""&gt; CameraBoom; </p>
<p>    // Needed so we can pick up the class in the constructor and spawn it elsewhere<br />
    TSubclassOf&lt;aactor&gt; CharacterClass; </p>
<p>    // Pointer to the actual character. We replicate it so we know its location for the camera on the client<br />
    UPROPERTY(Replicated) ADemoCharacter* Character; </p>
<p>    // The AI Controller we will use to auto-navigate the player<br />
    AAIController* PlayerAI; </p>
<p>    // We spawn the real player character and other such elements here<br />
    virtual void BeginPlay() override; </p>
<p>    // Use do keep this actor in sync with the real one<br />
    void Tick(float DeltaTime); </p>
<p>    // Used by the controller to get moving to work<br />
    void MoveToLocation(const ADemoPlayerController* controller, const FVector&amp;amp; vector);<br />
}; </p>
<p>[/code]</p>
<p>and the definition:</p>
<p>[code language="cpp"]</p>
<p>#include "Demo.h"<br />
#include "DemoCharacter.h"<br />
#include "AIController.h"<br />
#include "DemoPlayerProxy.h"<br />
#include "UnrealNetwork.h"</p>
<p>ADemoPlayerProxy::ADemoPlayerProxy(const class FPostConstructInitializeProperties&amp;amp; PCIP)<br />
: Super(PCIP)<br />
{<br />
	// Don't rotate character to camera direction<br />
	bUseControllerRotationPitch = false;<br />
	bUseControllerRotationYaw = false;<br />
	bUseControllerRotationRoll = false;</p>
<p>	// It seems that without a RootComponent, we can't place the Actual Character easily<br />
	TSubobjectPtr&amp;lt;UCapsuleComponent&amp;gt; TouchCapsule = PCIP.CreateDefaultSubobject&lt;ucapsulecomponent&gt;(this, TEXT("dummy"));<br />
	TouchCapsule-&amp;gt;InitCapsuleSize(1.0f, 1.0f);<br />
	TouchCapsule-&amp;gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);<br />
	TouchCapsule-&amp;gt;SetCollisionResponseToAllChannels(ECR_Ignore);<br />
	RootComponent = TouchCapsule;</p>
<p>	// Create a camera boom...<br />
	CameraBoom = PCIP.CreateDefaultSubobject&amp;lt;USpringArmComponent&amp;gt;(this, TEXT("CameraBoom"));<br />
	CameraBoom-&amp;gt;AttachTo(RootComponent);<br />
	CameraBoom-&amp;gt;bAbsoluteRotation = true; // Don't want arm to rotate when character does<br />
	CameraBoom-&amp;gt;TargetArmLength = 800.f;<br />
	CameraBoom-&amp;gt;RelativeRotation = FRotator(-60.f, 0.f, 0.f);<br />
	CameraBoom-&amp;gt;bDoCollisionTest = false; // Don't want to pull camera in when it collides with level</p>
<p>	// Create a camera...<br />
	TopDownCameraComponent = PCIP.CreateDefaultSubobject&amp;lt;UCameraComponent&amp;gt;(this, TEXT("TopDownCamera"));<br />
	TopDownCameraComponent-&amp;gt;AttachTo(CameraBoom, USpringArmComponent::SocketName);<br />
	TopDownCameraComponent-&amp;gt;bUseControllerViewRotation = false; // Camera does not rotate relative to arm</p>
<p>	if (Role == ROLE_Authority)<br />
	{<br />
		static ConstructorHelpers::FObjectFinder&amp;lt;UClass&amp;gt; PlayerPawnBPClass(TEXT("/Game/Blueprints/MyCharacter.MyCharacter_C"));<br />
		CharacterClass = PlayerPawnBPClass.Object;<br />
	}</p>
<p>}</p>
<p>void ADemoPlayerProxy::BeginPlay()<br />
{<br />
	Super::BeginPlay();<br />
	if (Role == ROLE_Authority)<br />
	{<br />
		// Get current location of the Player Proxy<br />
		FVector Location =  GetActorLocation();<br />
		FRotator Rotation = GetActorRotation();</p>
<p>		FActorSpawnParameters SpawnParams;<br />
		SpawnParams.Owner = this;<br />
		SpawnParams.Instigator = Instigator;<br />
		SpawnParams.bNoCollisionFail = true;</p>
<p>		// Spawn the actual player character at the same location as the Proxy<br />
		Character = Cast&amp;lt;ADemoCharacter&amp;gt;(GetWorld()-&amp;gt;SpawnActor(CharacterClass, &amp;amp;Location, &amp;amp;Rotation, SpawnParams));</p>
<p>		// We use the PlayerAI to control the Player Character for Navigation<br />
		PlayerAI = GetWorld()-&amp;gt;SpawnActor&amp;lt;AAIController&amp;gt;(GetActorLocation(), GetActorRotation());<br />
		PlayerAI-&amp;gt;Possess(Character);<br />
	}</p>
<p>}</p>
<p>void ADemoPlayerProxy::Tick(float DeltaTime)<br />
{</p>
<p>	Super::Tick(DeltaTime);<br />
	if (Character)<br />
	{<br />
		// Keep the Proxy in sync with the real character<br />
		FTransform CharTransform = Character-&amp;gt;GetTransform();<br />
		FTransform MyTransform = GetTransform();</p>
<p>		FTransform Transform;<br />
		Transform.LerpTranslationScale3D(CharTransform, MyTransform, ScalarRegister(0.5f));</p>
<p>		SetActorTransform(Transform);</p>
<p>	}<br />
}</p>
<p>void ADemoPlayerProxy::MoveToLocation(const ADemoPlayerController* controller, const FVector&amp;amp; DestLocation)<br />
{<br />
	/** Looks easy - doesn't it.<br />
	 *  What this does is to engage the AI to pathfind.<br />
	 *  The AI will then "route" the character correctly.<br />
	 *  The Proxy (and with it the camera), on each tick, moves to the location of the real character<br />
	 *<br />
	 *  And thus, we get the illusion of moving with the Player Character<br />
	 */<br />
	PlayerAI-&amp;gt;MoveToLocation(DestLocation);<br />
}</p>
<p>void ADemoPlayerProxy::GetLifetimeReplicatedProps(TArray&amp;lt; class FLifetimeProperty &amp;gt; &amp;amp; OutLifetimeProps) const<br />
{</p>
<p>	Super::GetLifetimeReplicatedProps(OutLifetimeProps);</p>
<p>	// Replicate to Everyone<br />
	DOREPLIFETIME(ADemoPlayerProxy, Character);<br />
}&lt;/ucapsulecomponent&gt;<br />
[/code]</p>
<p>We'll now cover changes to the Player Controller. We'll rewire it here to ask the proxy to move, which will in turn ask the AIController to find a path and move the real player character. </p>
<p>This involves changing the <em>SetMoveDestination</em> method to call a server side method to move the character. When the character moves, the player Proxy will automatically mirror the movements.</p>
<p>In the header file, add the following function</p>
<p>[code language="cpp"]</p>
<p>    /** Navigate player to the given world location (Server Version) */<br />
    UFUNCTION(reliable, server, WithValidation)<br />
    void ServerSetNewMoveDestination(const FVector DestLocation);</p>
<p>[/code]</p>
<p>Now let's implement it (DemoPlayerController.cpp):</p>
<p>[code language="cpp"]</p>
<p>bool ADemoPlayerController::ServerSetNewMoveDestination_Validate(const FVector DestLocation)<br />
{<br />
	return true;<br />
}</p>
<p>/* Actual implementation of the ServerSetMoveDestination method */<br />
void ADemoPlayerController::ServerSetNewMoveDestination_Implementation(const FVector DestLocation)<br />
{<br />
	ADemoPlayerProxy* Pawn = Cast&lt;ademoplayerproxy&gt;(GetPawn());<br />
	if (Pawn)<br />
	{<br />
		UNavigationSystem* const NaDemoys = GetWorld()-&amp;gt;GetNavigationSystem();<br />
		float const Distance = FVector::Dist(DestLocation, Pawn-&amp;gt;GetActorLocation());</p>
<p>		// We need to issue move command only if far enough in order for walk animation to play correctly<br />
		if (NaDemoys &amp;amp;&amp;amp; (Distance &amp;gt; 120.0f))<br />
		{<br />
			//NaDemoys-&amp;gt;SimpleMoveToLocation(this, DestLocation);<br />
			Pawn-&amp;gt;MoveToLocation(this, DestLocation);<br />
		}<br />
	}</p>
<p>}</p>
<p>[/code]</p>
<p>And finally, the rewiring of the original method:</p>
<p>[code language="cpp"]<br />
void ADemoPlayerController::SetNewMoveDestination(const FVector DestLocation)<br />
{<br />
	ServerSetNewMoveDestination(DestLocation);<br />
}<br />
[/code]</p>
<p> </p>
<p>Finally, in terms of the character class, the only change is really to remove the camera components that we moved to the Player Proxy which I shall leave to you :-p</p>
<p></body></html></p>
