---
layout: post
title: Breaking Software Down
date: 2008-12-15 15:53:43.000000000 +00:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Software
tags:
- "*nix"
- Brave New World
- Coding Horror
- Collaboration
- COM
- Contact Management
- CORBA
- find
- Firefox
- GNOME Evolution
- grep
- Integration
- Interoperability
- Jeff Atwood
- Mylyn
- OLE
- REST
- RPC
- Safari
- sed
- SOAP
- Software Component
- Software Garden
- Subclipse
- Subversive
- Thunderbird
meta:
  _edit_last: '48492462'
  restapi_import_id: 591d994f7aad5
  original_post_id: '56'
  _wp_old_slug: '56'
  geo_public: '0'
  _publicize_job_id: '15641121183'
  _elasticsearch_data_sharing_indexed_on: '2024-11-18 14:54:34'
permalink: "/2008/12/15/breaking-software-down/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<html><body><br />
<a title="Tending Your Software Garden" href="http://www.codinghorror.com/blog/archives/000987.html" target="_blank" rel="noopener">Jeff Atwood likens software development to tending a garden.</a> I can relate to this. In fact, I would like to ask, if you have a nice plant in one of your gardens, how complicated is it to "copy" that across to another one?</p>
<p>I realise that I am moving away from the analogy here but there is an important concept here. Libraries were born out of the desire to share and distribute code to be re-used.</p>
<p>The idea for <a title="Remote Procedure Call" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">Remote Procedure Calls</a> dates as far back as 1976. Microsoft brought along <a title="Object Linking and Embedding" href="http://en.wikipedia.org/wiki/Object_Linking_and_Embedding" target="_blank" rel="noopener">OLE</a> and then <a title="Component Object Model" href="http://en.wikipedia.org/wiki/Component_Object_Model" target="_blank" rel="noopener">COM</a> made this more generic and better.</p>
<p>RPC is widely in use these days and there are several other mechanisms for inter process communication including <a title="Common Object Request Broker Architecture" href="http://en.wikipedia.org/wiki/CORBA" target="_blank" rel="noopener">CORBA</a>, <a title="Representational State Transfer" href="http://en.wikipedia.org/wiki/REST" target="_blank" rel="noopener">REST</a> &amp; <a title="Simple Object Access Protocol" href="http://en.wikipedia.org/wiki/SOAP_(protocol)" target="_blank" rel="noopener">SOAP</a>.</p>
<p>I don't think software is broken down into small enough components. *nix is great in that you can tag a whole bunch of commands together on the command line to do some amazing things. I have personally piped data through a dozen or so commands and scripts to do some interesting things.</p>
<p>If we could break everything down into individual components that could be linked together, we would have a massive arsenal of interoporable tools that each user can pick and choose to put together very powerful solutions.</p>
<p>How many times have you found a piece of software that does one thing really well, but fails in something else. Then found another piece of software that does the other thing really well.</p>
<p>For example, the extensibility of <a title="Firefox" href="http://www.mozilla.org/firefox" target="_blank" rel="noopener">Firefox</a> is fantastic but I love the rendering of <a title="Safari Web Browser" href="http://www.apple.com/safari/" target="_blank" rel="noopener">Safari</a>. I love the Contact Management within <a title="Evolution" href="http://projects.gnome.org/evolution/" target="_blank" rel="noopener">Evolution</a> and the Mail capabilities of <a title="Thunderbird" href="http://www.mozilla.org/thunderbird" target="_blank" rel="noopener">Thunderbird</a>.</p>
<p>Why don't we break each software down into each of it's individual components (and I am not talking about libraries here) and allow them to be deployed as services usable by other pieces of software.</p>
<p>In other words, release the contact management capabilities of Evolution as a product of it's own right with a pre-defined API that any application can link into (including perhaps a web interface). Release the Mail management component of Thunderbird as a service, Release GUI's as a component. Then we can pick any GUI we want, link into a specific mail component and another addressbook component.</p>
<p>Do one thing and do it well. In fact, let's take it one step further and release a public API for each software component - an API for Mail, one for Contact Management and so on.</p>
<p>Each software component can then be a black box that delivers this API.</p>
<p>Choice can be a bad thing if it makes it difficult to choose - <a title="Subclipse" href="http://subclipse.tigris.org" target="_blank" rel="noopener">Subclipse</a> vs <a title="Subversive" href="http://www.eclipse.org/subversive" target="_blank" rel="noopener">Subversive</a> is a good example of this. Let us however, not confuse choice with flexibility.</p>
<p>Let's say that you want to find all the files within a folder modified within the last 3 days containing the text "abracadabra" and then replace all occurences in those files of the world "super" Â with "hyper".</p>
<p>To do this in linux, all you would do is chain find (to identify files modified in the last 3 days), grep (to identify only the files that contain "abracadabra") and sed (to do the replacement).</p>
<p>If you know these commands well enough, you could chain something together in half a minute or so. You could probably figure out how to do this with the search tools in Windows within a minute or so but where this really shines is if there are thousands of files that needs to be processed. With other search tools, you would have to wait for the original search results to be returned before running to replace operation. This takes up the users time.</p>
<p>With the chaining of commands, I have run it and worked on something else while it completes.</p>
<p>Let me visualise a brave new world:</p>
<p>In this world, all software would be interoperable components. For example, there would be components for:</p>
<ul>
<li>Mail account management (Perhaps genericised into configuration management)</li>
<li>Text composition (usage for mail, documents, plain text et al)</li>
<li>Text reading (again, usable for mail, documents, plain text et al)</li>
<li>Spam Filtering (already available to some extent)</li>
<li>Contact Management (optionally linked into organisation's LDAP server)</li>
<li>Task Management (Standalone <a title="Eclipse - Mylyn" href="http://www.eclipse.org/mylyn/" target="_blank" rel="noopener">Mylyn</a> if you know the product)</li>
<li>Scheduling (or calendering if you prefer that term)</li>
</ul>
<p>If all of these components were interoperable, then there would a <a title="Graphical User Interface" href="http://en.wikipedia.org/wiki/Graphical_user_interface" target="_blank" rel="noopener">GUI</a> that is generic and could bring all of these together. In this way, the people working on each of the components could concentrate on doing one thing and one thing well.</p>
<p>If we then start working on public API's in a collaborative fashion, each of the component could be fleshed out to be as flexible and complete as necessary to gain maximum benefit.</p>
<p>If these components provided the services as a network based API, it would also allow for the components to be distributed across a network providing redundancy and efficiency. This makes it easier to turn each desktop into more of dump terminal concentrating purely on user interaction and getting closer to the <a title="Invisible Interface" href="http://drone-ah.com/2008/12/12/invisible-interface/" target="_blank" rel="noopener">invisible interface.</a></p>
<p>Software as a service has taken a step in the right direction. Can we take a leap and have software component as a service...</body></html></p>
