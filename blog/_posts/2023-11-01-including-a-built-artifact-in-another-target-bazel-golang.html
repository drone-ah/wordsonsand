---
layout: post
title: Including a built artifact in another target (Bazel, golang)
date: 2023-11-01 19:42:30.000000000 +00:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags:
- aws-lambda
- bazel
- golang
- pulumi
meta:
  _last_editor_used_jetpack: block-editor
  wpcom_is_first_post: '1'
  _publicize_job_id: '88995902253'
  timeline_notification: '1698867751'
  wordads_ufa: s:wpcom-ufa-v4:1698868013
  _elasticsearch_data_sharing_indexed_on: '2024-11-18 14:55:04'
permalink: "/2023/11/01/including-a-built-artifact-in-another-target-bazel-golang/"
---
<p><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"><br />
<!-- wp:paragraph --><html><body></p>
<p>We use pulumi to do IaC and we use a monorepo with Bazel as the build tool. We have out modules set out as following</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>One of the requirements we have is to build a lambda module and then deploy it. The lambda module is a target being built by Bazel (golang, but shouldn't matter):</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:code --></p>
<pre class="wp-block-code"><code>go_binary(
    name = "lambda_module",
    visibility = ["//visibility:public"],
)</code></pre>
<p><!-- /wp:code --></p>
<p><!-- wp:paragraph --></p>
<p>We then have the iac module, which should get the built version of the above module, so that it can then upload it into lambda</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:code --></p>
<pre class="wp-block-code"><code>go_binary(
    name = "iac",
    args = [
        "-lambda_module",
        "$(location //products/productA/module/lambda_module)",
    ],
    data = ["//products/productA/module/lambda_module"],
    visibility = ["//visibility:public"],
)</code></pre>
<p><!-- /wp:code --></p>
<p><!-- wp:more --><br />
<!--more--><br />
<!-- /wp:more --></p>
<p><!-- wp:paragraph --></p>
<p>There are two key parameters here to note:</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list --></p>
<ul>
<!-- wp:list-item --></p>
<li>
<code>args</code>: We generate the path to the target module using <code> //products/productA/module/lambda_module)</code>
</li>
<p><!-- /wp:list-item --></p>
<p><!-- wp:list-item --></p>
<li>
<code>data</code>: We use the data tag to ensure that the built output is included when building/running this target</li>
<p><!-- /wp:list-item -->
</ul>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p>We then need to use runfiles support within golang to be ablet to identify the correct location for the built binary. The reason this part is complex is to be able to support multiple operating systems. I should caveat that I have only got this working on Linux, but Mac/Win shouldn't be too different.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:code --></p>
<pre class="wp-block-code"><code>package main

import (
	_ "embed"
	"flag"
	"fmt"
	"github.com/bazelbuild/rules_go/go/runfiles"
	"path/filepath"
)

func main() {

	var webhookAuth = flag.String("webhook_auth", "", "bin for webhook_auth")
	flag.Parse()
	fmt.Printf("param : %s \n", *webhookAuth)

	path, err := runfiles.Rlocation(fmt.Sprintf("workspace_name/%s", *webhookAuth))
	fmt.Printf("rLoc path: %s, err: %v \n", path, err)

	symlinks, err := filepath.EvalSymlinks(path)
	fmt.Printf("evaluated path: %s, err: %v \n", symlinks, err)

}
</code></pre>
<p><!-- /wp:code --></p>
<p><!-- wp:paragraph --></p>
<p>We use the flag module to retrieve the path passed in as a runtime parameter</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>We use <code>runfiles.Rlocation</code> to pick up the "real" path to the file, prepending the workspace name to the start. You can <a href="https://bazel.build/rules/lib/globals/workspace#workspace">define the workspace name</a> in the root WORKSPACE file with <code>workspace(name = "workspace_name")</code></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Finally, resolve the Symlink to get the actual file path</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2 class="wp-block-heading">References</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>There are similar mechanisms to find the rLocation in other languages, a couple of which are described in <a href="https://docs.google.com/document/d/e/2PACX-1vSDIrFnFvEYhKsCMdGdD40wZRBX3m3aZ5HhVj4CtHPmiXKDCxioTUbYsDydjKtFDAzER5eg7OjJWs3V/pub">its design document</a></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>There is some documentation in <code>rules_go</code> around <a href="https://github.com/bazelbuild/rules_go#how-do-i-access-go_binary-executables-from-go_test">accessing <code>go_binary</code> from <code>go_test</code></a> which I referenced and updated to get the above example</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>I found the above link from <a href="https://stackoverflow.com/questions/70193581/feed-bazel-output-to-another-bazel-rule">a stackoverflow post about feeding bazel output to another bazel rule</a></p>
<p><!-- /wp:paragraph --><br />
</body></html></p>
