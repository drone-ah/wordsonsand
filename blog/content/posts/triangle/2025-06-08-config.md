---
layout: post
title: Managing Configuration
date: 2025-06-08 20:47:05 +1:00
type: post
published: true
status: publish
categories:
  - triangle
tags:
  - config
meta:
redirect_from:
  - /s/tconfig
---

Before making the game available for playtesting, I wanted the player to be able
to configure the game to some degree.

As a starting point, my keyboard layout is `colemak`, and I doubt that the
controls I use would suit the majority of players.

I am putting off a UI based config management option down the road (did I
mention that I do not enjoy GUI work?). As such I've been pondering alternative
configuration options.

## Platform independence

Before I even get to that, the first problem I need to solve is a way to
determine the location for the config files independent of the platform.

Fortunately, [known-folders](https://github.com/ziglibs/known-folders) came to
the rescue and provided an easy to use framework that can be used to determine
the various relevant locations for multiple platforms.

```zig
const known_folders = @import("known-folders");
const maybe_config = try known_folders.getPath(allocator, .roaming_configuration);
if (maybe_config) |config| {
    defer allocator.free(config);
    std.debug.print("roaming config path: {s}\n", .{config});
}
```

<!-- more -->

## Locations

There three real locations of relevance for triangle

- The binary / package
- Config, technically, split into two
  - user (on in windows parlance, remote, and can be shared across computers)
  - system (in windows parlance, local, and is specific to that system)
- Save Data

## Config Files

With that sorted out, the next bit is to identify the relevant config files. I
expect that triangle will continue to use these, and will eventually just get a
UI config option as well.

### User Config

There are two main bits of user configuration

- Preference like controls
- System details like resolution

I am currently unsure when it'll support system config.

### Game Config

There are two bits of config that the game will store. One set of config is to
remember game choices the user has made.

#### Remember Player Actions

For example, it will be useful to show the user details of changes to the game
since they last played. To do this, we need to track the last set of changes
that the user saw.

The game will show a notice on startup about its extremely early access status,
and provide an option for the user to hide that in the future. We need to save
that somewhere too.

#### Telemetry

The second bit of config is metrics. While a lot of games will simply send
telemetry information directly to the developer, player privacy is really
important to me. I recognise that I will get far less data because of this, and
that there will be a bit of survivorship bias with the data - but I feel that
privacy is more important.

The way I want telemetry to work is that it will all be saved in a human
readable telemetry file in the config file location.

The location will also store logs (if enabled).

## Setting Config

In terms of allowing the player to manage config, there are a couple of
challenges:

- Providing enough documentation that it is easy to do
- Allowing for updates, particularly to the addition of new keys

To tackle this, I am going to provide an annotated template file with all the
config options. The user can create a separate file based on this with **only**
the config they wish to override.

It will be tricky to change how particular parameters are configured. E.g. If a
single value key needs to switch to an array for. I'd be loathe so sprinkle the
code with checks for legacy keys/formats. We'll play it by ear.

I considered updating the config file automatically but this would not preserve
any comments that the user has left behind. I could offer the user the option of
updating the file automatically with any changes, but I am not sure it's
straightforward enough to automate it.

## Format

I've been considering `toml` and `yaml` for this, with
[zig-toml](https://github.com/sam701/zig-toml/) and
[zig-yaml](https://github.com/kubkon/zig-yaml) respectively.

`zig-yaml` seems to be more active (more stars, forks, issues and pr's and
currently also the more recent commit).

I am also more familiar with and prefer yaml.

However, it does not currently support default values. I would like the user to
have to specify only the config they'd like to override. `zig-yaml` currently
expects all the keys to be defined if you want to parse it into a struct.

[#85](https://github.com/kubkon/zig-yaml/issues/85) should bring it in, but I
[could not get it to work](https://github.com/kubkon/zig-yaml/issues/92)

So, I tried out `zig-toml` and the test worked the first time.

```zig
const std = @import("std");

const Controls = struct {
    forward: []const u8 = "w",
    craft: []const u8 = "q",
    inventory: []const u8 = "e",
};

const User = struct {
    controls: Controls = .{},
};

test "load partial toml config" {
    const toml = @import("toml");
    const allocator = std.testing.allocator;
    var parser = toml.Parser(User).init(allocator);
    defer parser.deinit();

    const source =
        \\[controls]
        \\craft = "s"
    ;
    var result = try parser.parseString(source);
    defer result.deinit();

    const config = result.value;
    const default = User{};
    try std.testing.expectEqualStrings(default.controls.forward, config.controls.forward);
    try std.testing.expectEqualStrings("s", config.controls.craft);
}
```
